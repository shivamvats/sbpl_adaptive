/*
 * Copyright (c) 2011, Kalin Gochev
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the copyright holder nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/** \author Kalin Gochev */

#ifndef SBPL_ADAPTIVE_COLLISION_CHECKING_URDF_COLLISION_MODEL_H
#define SBPL_ADAPTIVE_COLLISION_CHECKING_URDF_COLLISION_MODEL_H

// standard includes
#include <memory>
#include <ostream>
#include <utility>
#include <unordered_map>

// system includes
#include <Eigen/Core>
#include <Eigen/Geometry>
#include <boost/shared_ptr.hpp>
#include <ros/ros.h>
#include <smpl/forward.h>
#include <sbpl/sbpl_exception.h>
#include <urdf/model.h>

// project includes
#include <sbpl_adaptive_collision_checking/sbpl_collision_model.h>

namespace adim {

/// A struct that contains the same joint variable position information as a
/// RobotState associated with a RobotModel, but without containing any
/// velocity, effort, or frame information.
struct URDFModelCoords : ModelCoords
{
    std::vector<double> positions;

    URDFModelCoords() = default;

    URDFModelCoords(const std::vector<double> &positions) :
        positions(positions)
    { }

    URDFModelCoords(std::vector<double> &&positions) :
        positions(std::move(positions))
    { }
};

std::ostream &operator<<(std::ostream &o, const URDFModelCoords &coords);

struct AttachedObject
{
    std::string name;
    std::vector<Sphere> spheres;
};

SBPL_CLASS_FORWARD(URDFCollisionModel);

/// This class represents a collision model for a robot.
///
/// The geometry of the robot is approximated by a set of spheres attached to
/// links in the robot model. The spheres are typically designed by the user,
/// and are added to the collision model by addCollisionSphere().
///
/// Spheres may be automatically generated by a call to
/// computeSpheresFromURDFModel(). This will generate a dense set of spheres by
/// voxelizing the collision geometry in the robot model and placing a sphere at
/// each occupied voxel. This often results in superfluous self collisions. The
/// function autoIgnoreSelfCollisions() may be used to automatically prune away
/// pairs of spheres which are collision in the default, or some other state of
/// the robot known to not be in self collision.
///
/// Some additional functionality for checking validity of robot states is
/// provided:
///
/// Joint limit checking can be performed by calling checkLimits().
///
/// The center of mass of the robot at a given state can be computed by calling
/// computeCOM() for checking against a support polygon.
class URDFCollisionModel : public SBPLCollisionModel
{
public:

    URDFCollisionModel();
    ~URDFCollisionModel();

    /// \name Initialization
    ///@{
    virtual bool initFromParam(const std::string &robot_desc_param_name);

    virtual bool initFromURDF(
        const std::string &urdf_string,
        const std::string &srdf_string);

    virtual bool initFromModel(
        const moveit::core::RobotModelPtr &robot_model);
    ///@}

    /// \name Model Information
    ///@{
    auto getURDF() const -> const boost::shared_ptr<const urdf::ModelInterface> &;
    auto getSRDF() const -> const boost::shared_ptr<const srdf::Model> &;
    auto getRobotModel() const -> const moveit::core::RobotModelConstPtr &;
    auto getStateAt(const URDFModelCoords &coords) const -> moveit::core::RobotStatePtr;

    void PrintModelInfo(std::ostream &o) const;
    auto getDefaultCoordinates() const -> URDFModelCoords;
    ///@}

    /// \name Joint Limits
    ///@{
    bool checkLimits(const URDFModelCoords &coords) const;
    ///@}

    /// \name Forward Kinematics
    ///@{
    auto getLinkGlobalTransform(
        const URDFModelCoords &coords,
        const std::string &link_name) const
        -> const Eigen::Affine3d &;

    auto getLinkGlobalTransform(
        const URDFModelCoords &coords,
        const moveit::core::LinkModel *link) const
        -> const Eigen::Affine3d &;
    ///@}

    /// \name Inverse Kinematics
    ///@{
    bool computeGroupIK(
        const std::string &group_name,
        const Eigen::Affine3d &pose,
        const URDFModelCoords &seed,
        URDFModelCoords &sol,
        bool allow_approx_solutions = false,
        int num_attempts = 0,
        double timeout = 0.0);

    bool computeGroupIK(
        const moveit::core::JointModelGroup *group,
        const Eigen::Affine3d &pose,
        const URDFModelCoords &seed,
        URDFModelCoords &sol,
        bool allow_approx_solutions = false,
        int num_attempts = 0,
        double timeout = 0.0);
    ///@}

    /// \name Inertial Properties
    ///@{
    bool computeCOM(
        const URDFModelCoords &coords,
        Eigen::Vector3d &com,
        double &mass) const;
    ///@}

    /// \name Collision Model Construction
    ///@{
    virtual bool computeSpheresFromURDFModel(
        double res,
        const std::vector<std::string> &ignore_collision_links,
        const std::vector<std::string> &contact_links);

    void addContactSpheres(
        const std::string &link_name,
        const std::vector<Sphere> &s);

    void addCollisionSpheres(
        const std::string &link_name,
        const std::vector<Sphere> &s);

    void addContactSphere(const std::string &link_name, Sphere s);

    void addCollisionSphere(const std::string &link_name, Sphere s);

    bool attachObjectToLink(
        const std::string &link_name,
        const Eigen::Affine3d &pose,
        const shapes::Shape &object,
        const std::string &object_name,
        double res);
    ///@}

    /// \name Self Collisions
    ///@{
    virtual void autoIgnoreSelfCollisions();
    virtual void autoIgnoreSelfCollisions(const URDFModelCoords &coords);

    void printIgnoreSelfCollisionLinkPairs(std::ostream& o);

    void addIgnoreSelfCollisionLinkPair(
        const std::pair<std::string, std::string> &pair);
    void addIgnoreSelfCollisionLinkPairs(
        const std::vector<std::pair<std::string, std::string>> &pairs);

    bool checkSelfCollisions(const URDFModelCoords &coords) const;

    auto getSelfCollisions(const URDFModelCoords &coords) const
        -> std::vector<std::pair<std::string, std::string>>;
    ///@}

    /// \name Type-Aware Overloads of SBPLCollisionModel functions
    ///@{
    bool getModelCollisionSpheres(
        const URDFModelCoords &coords,
        std::vector<Sphere> &spheres) const;

    bool getModelContactSpheres(
        const URDFModelCoords &coords,
        std::vector<Sphere> &spheres) const;

    bool getModelPathCollisionSpheres(
        const URDFModelCoords &coords0,
        const URDFModelCoords &coords1,
        int steps,
        std::vector<Sphere> &spheres) const;

    bool getModelPathContactSpheres(
        const URDFModelCoords &coords0,
        const URDFModelCoords &coords1,
        int steps,
        std::vector<Sphere> &spheres) const;
    ///@}

    /// \name Interpolation
    ///@{
    virtual bool getInterpolatedCoordinates(
        const URDFModelCoords &coords0,
        const URDFModelCoords &coords1,
        double t,
        URDFModelCoords &interp) const;

    virtual bool getInterpolatedPath(
        const URDFModelCoords &coords0,
        const URDFModelCoords &coords1,
        double resolution,
        std::vector<URDFModelCoords> &path) const;

    virtual bool getInterpolatedPath(
        const URDFModelCoords &coords0,
        const URDFModelCoords &coords1,
        double resolution,
        std::vector<URDFModelCoords> &path,
        int max_depth) const;

    virtual bool getInterpolatedPath(
        const URDFModelCoords &coords0,
        const URDFModelCoords &coords1,
        int steps,
        std::vector<URDFModelCoords> &path) const;
    ///@}

    /// \name Visualization
    ///@{
    auto getModelSelfCollisionVisualization(
        const URDFModelCoords &coords,
        const std::string &frame_id,
        const std::string &ns,
        const std_msgs::ColorRGBA &col,
        int &idx) const
        -> visualization_msgs::MarkerArray;

    auto getModelBasicVisualizationByLink(
        const URDFModelCoords &coords,
        const std::string &frame_id,
        const std::string &ns,
        int &idx) const
        -> visualization_msgs::MarkerArray;

    auto getModelBasicVisualization(
        const URDFModelCoords &coords,
        const std::string &frame_id,
        const std::string &ns,
        std_msgs::ColorRGBA col,
        int &idx) const
        -> visualization_msgs::MarkerArray;

    auto getModelVisualization(
        const URDFModelCoords &coords,
        const std::string &frame_id,
        const std::string &ns,
        const std_msgs::ColorRGBA &col,
        int &idx) const
        -> visualization_msgs::MarkerArray;

    auto getAttachedObjectsVisualization(
        const URDFModelCoords &coords,
        const std::string &frame_id,
        const std::string &ns,
        const std_msgs::ColorRGBA &col,
        int &idx) const
        -> visualization_msgs::MarkerArray;
    ///@}

    /// \name Required Functions from SBPLCollisionModel
    ///@{
    bool checkLimits(const ModelCoords &coord) const override;

    bool getModelCollisionSpheres(
        const ModelCoords &coords,
        std::vector<Sphere> &spheres) const override;

    bool getModelContactSpheres(
        const ModelCoords &coords,
        std::vector<Sphere> &spheres) const override;

    bool getModelContactSpheres(
        const ModelCoords &coords,
        const std::string &link_name,
        std::vector<Sphere> &spheres) const override;

    bool getModelPathCollisionSpheres(
        const ModelCoords &coords0,
        const ModelCoords &coords1,
        int steps,
        std::vector<Sphere> &spheres) const override;

    bool getModelPathContactSpheres(
        const ModelCoords &coords0,
        const ModelCoords &coords1,
        int steps,
        std::vector<Sphere> &spheres) const override;

    visualization_msgs::MarkerArray getModelVisualization(
        const ModelCoords &coords,
        const std::string &frame_id,
        const std::string &ns,
        const std_msgs::ColorRGBA &col,
        int &idx) const override;
    ///@}

protected:

    boost::shared_ptr<const urdf::ModelInterface> urdf_;
    boost::shared_ptr<const srdf::Model> srdf_;

    std::vector<std::string> links_with_collision_spheres_;
    std::vector<std::string> links_with_contact_spheres_;

    std::vector<std::pair<std::string, std::string>> self_collision_ignore_pairs_;

    std::unordered_map<std::string, std::vector<Sphere>> collision_spheres_;
    std::unordered_map<std::string, std::vector<Sphere>> contact_spheres_;

    std::unordered_map<std::string, std::vector<AttachedObject>> attached_objects_;

    robot_model::RobotModelConstPtr robot_model_;
    robot_state::RobotStatePtr robot_state_;

    void updateFK(const URDFModelCoords &coords) const;

    void updateFK(
        moveit::core::RobotState &state,
        const URDFModelCoords &coords) const;

    bool hasIgnoreSelfPair(
        const std::string &link1,
        const std::string &link2) const;

    bool getLinkCollisionSpheres(
        const URDFModelCoords &coords,
        const std::string &link_name,
        std::vector<Sphere> &spheres) const;
    bool getLinkCollisionSpheres_CurrentState(
        const std::string &link_name,
        std::vector<Sphere> &spheres) const;

    bool getLinkContactSpheres(
        const URDFModelCoords &coords,
        const std::string &link_name,
        std::vector<Sphere> &spheres) const;
    bool getLinkContactSpheres_CurrentState(
        const std::string &link_name,
        std::vector<Sphere> &spheres) const;

    bool getLinkAttachedObjectsSpheres(
        const std::string &link_name,
        const Eigen::Affine3d link_tfm,
        std::vector<Sphere> &spheres) const;

    bool getInterpolatedPath(
        const URDFModelCoords &coords0,
        const URDFModelCoords &coords1,
        double resolution,
        std::vector<URDFModelCoords> &path,
        int depth,
        int max_depth) const;

    bool initRobotModelFromURDF(
        const std::string &urdf_string,
        const std::string &srdf_string);

    bool hasAttachedObject(
        const std::string &link_name,
        const std::string &object_name) const;
    bool hasAttachedObjects(const std::string &link_name) const;
    const std::vector<AttachedObject> getAttachedObjects(
            const std::string &link_name) const;

    bool attachObject(
        const std::string &link_name,
        const AttachedObject &obj);

    bool computeShapeBoundingSpheres(
        const shapes::Shape &shape,
        double res,
        std::vector<Sphere> &spheres);
};

///////////////////////////////////////
// URDFCollisionModel Implementation //
///////////////////////////////////////

inline auto URDFCollisionModel::getURDF() const
    -> const boost::shared_ptr<const urdf::ModelInterface> &
{
    return urdf_;
}

inline auto URDFCollisionModel::getSRDF() const
    -> const boost::shared_ptr<const srdf::Model> &
{
    return srdf_;
}

inline auto URDFCollisionModel::getRobotModel() const
    -> const moveit::core::RobotModelConstPtr &

{
    return robot_model_;
}

inline
bool URDFCollisionModel::getModelCollisionSpheres(
    const ModelCoords &coords,
    std::vector<Sphere> &spheres) const
{
    auto &c = static_cast<const URDFModelCoords&>(coords);
    return getModelCollisionSpheres(c, spheres);
}

inline
bool URDFCollisionModel::getModelContactSpheres(
    const ModelCoords &coords,
    std::vector<Sphere> &spheres) const
{
    auto &c = static_cast<const URDFModelCoords&>(coords);
    return getModelContactSpheres(c, spheres);
}

inline
bool URDFCollisionModel::getModelContactSpheres(
    const ModelCoords &coords,
    const std::string &link_name,
    std::vector<Sphere> &spheres) const
{
    auto &c = static_cast<const URDFModelCoords&>(coords);
    return getLinkContactSpheres(c, link_name, spheres);
}

inline
bool URDFCollisionModel::getModelPathCollisionSpheres(
    const ModelCoords &coords0,
    const ModelCoords &coords1,
    int steps,
    std::vector<Sphere> &spheres) const
{
    auto &c0 = static_cast<const URDFModelCoords&>(coords0);
    auto &c1 = static_cast<const URDFModelCoords&>(coords1);
    return getModelPathCollisionSpheres(c0, c1, steps, spheres);
}

inline
bool URDFCollisionModel::getModelPathContactSpheres(
    const ModelCoords &coords0,
    const ModelCoords &coords1,
    int steps,
    std::vector<Sphere> &spheres) const
{
    auto &c0 = static_cast<const URDFModelCoords&>(coords0);
    auto &c1 = static_cast<const URDFModelCoords&>(coords1);
    return getModelPathContactSpheres(c0, c1, steps, spheres);
}

inline
bool URDFCollisionModel::checkLimits(const ModelCoords &coord) const
{
    auto &c = static_cast<const URDFModelCoords&>(coord);
    return checkLimits(c);
}

inline
visualization_msgs::MarkerArray URDFCollisionModel::getModelVisualization(
    const ModelCoords &coords,
    const std::string &frame_id,
    const std::string &ns,
    const std_msgs::ColorRGBA &col,
    int &idx) const
{
    auto &c = static_cast<const URDFModelCoords&>(coords);
    return getModelVisualization(c, frame_id, ns, col, idx);
}

} // namespace adim

#endif
